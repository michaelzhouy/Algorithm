# 0120-三角形最小路径和

## 说明
给定一个三角形 `triangle`, 找出自顶向下的最小路径和。

每一步只能移动到下一行中相邻的结点上。相邻的结点 在这里指的是 下标 与 上一层结点下标 相同或者等于 上一层结点下标 + 1 的两个结点。也就是说, 如果正位于当前行的下标 `i` , 那么下一步可以移动到下一行的下标 `i` 或 `i + 1`

## 示例
```
输入：triangle = [[2],[3,4],[6,5,7],[4,1,8,3]]
输出：11
解释：如下面简图所示：
   2
  3 4
 6 5 7
4 1 8 3
自顶向下的最小路径和为 11（即, 2 + 3 + 5 + 1 = 11）

输入：triangle = [[-10]]
输出：-10
```

## 解 动态规划

### 思路
1. 定义状态: 设动态规划矩阵`dp`, `dp[i][j]`代表从左上角开始, 到达单元格$(i, j)$时最小路径和
2. 转移方程
$$
dp[i][j]=
\begin{cases}
dp[i - 1][0] + triangle[i][0] & \text{j=0}\\
dp[i - 1][j - 1] + triangle[i][j] & \text{i=j}\\
dp[i - ][j - 1] + dp[i - 1][j] & otherwise\\
\end{cases}
$$
3. 初始状态 `dp[0][0] = triangle[0][0]`
4. 返回值 `min(dp[-1])`

### 复杂度
1. 时间复杂度$O(N^2)$, `N`为`triangle`行数, 需要遍历`triangle`所有的元素, $O((N+1) \times N / 2)=O(N^2)$
2. 空间复杂度$O(1)$

```python
class Solution:
    def minimumTotal(self, triangle: List[List[int]]) -> int:
        m = len(triangle)
        if m == 1:
            return triangle[0][0]
        for i in range(1, m):
            triangle[i][0] += triangle[i - 1][0]
        for i in range(1, m):
            for j in range(1, i + 1):
                if j < i:
                    triangle[i][j] = min(triangle[i - 1][j - 1], triangle[i - 1][j]) + triangle[i][j]
                elif j == i:
                    triangle[i][j] = triangle[i - 1][j - 1] + triangle[i][j]
        return min(triangle[-1])
```