# 0139-单词拆分

## 说明
给定一个非空字符串 `s` 和一个包含非空单词的列表 `wordDict`, 判定 `s` 是否可以被空格拆分为一个或多个在字典中出现的单词

说明：
- 拆分时可以重复使用字典中的单词。
- 你可以假设字典中没有重复的单词。

## 示例
```
输入: s = "leetcode", wordDict = ["leet", "code"]
输出: true
解释: 返回 true 因为 "leetcode" 可以被拆分成 "leet code"

输入: s = "applepenapple", wordDict = ["apple", "pen"]
输出: true
解释: 返回 true 因为 "applepenapple" 可以被拆分成 "apple pen apple"。
      注意你可以重复使用字典中的单词

输入: s = "catsandog", wordDict = ["cats", "dog", "sand", "and", "cat"]
输出: false
```

## 解 动态规划

### 思路
1. 定义状态, 初始化 $dp = [False, ..., False]$, 长度为 `N + 1`, `dp[i]` 为 `s` 的前 `i` 位是否可以用 `wordDict` 中的单词表示
2. 转移方程
- 遍历字符串的所有子串, 遍历开始索引 `i`, 遍历区间 `[0, n)`:
  - 遍历结束索引 `j`, 遍历区间 `[i+1, n+1)`:
    - 若 $dp[i]=True$ 且 $s[i,\cdots,j)$ 在 `wordDict` 中, 则 $dp[j]=True$.
    - 解释: $dp[i]=True$ 说明 `s` 的前 `i` 位可以用 `wordDict` 表示, $s[i,\cdots,j)$ 出现在 `wordDict` 中, 说明 `s` 的前 `j` 位可以表示
1. 初始状态, $dp[0] = True$, 空串可以被表示
2. 返回值, $dp[-1]$

### 复杂度
1. 时间复杂度$O(N^2)$, `N` 为字符串长度
2. 空间复杂度$O(N)$, dp需要占用$O(N)$的额外空间

```python
class Solution:
    def wordBreak(self, s: str, wordDict: List[str]) -> bool:
        n = len(s)
        dp = [False] * (n + 1)
        dp[0] = True
        for i in range(n):
            for j in range(i + 1, n + 1):
                if dp[i] and (s[i: j] in wordDict):
                    dp[j] = True
        return dp[-1]
```