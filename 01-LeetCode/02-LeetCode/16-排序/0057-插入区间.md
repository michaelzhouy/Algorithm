# 0057-插入区间

## 说明


## 示例
```
输入：intervals = [[1,3],[6,9]], newInterval = [2,5]
输出：[[1,5],[6,9]]

输入：intervals = [[1,2],[3,5],[6,7],[8,10],[12,16]], newInterval = [4,8]
输出：[[1,2],[3,10],[12,16]]
解释：这是因为新的区间 [4,8] 与 [3,5],[6,7],[8,10] 重叠。

输入：intervals = [], newInterval = [5,7]
输出：[[5,7]]
```

## 解 排序

### 思路
1. 将新的区间添加到原区间里去
2. 根据区间的左边界排序
3. 遍历循环(见代码)
- 如果结果集为空, 直接添加
- 比较结果集最后一项的右边界与当前区间的左边界
  - 前者小, 将当前区间添加到结果集中
  - 前者大, 更新结果集最后一项的右边界

### 复杂度
1. 时间复杂度$O(NlogN)$, 排序需要$O(NlogN)$的时间
2. 空间复杂度$O(logN)$, 排序需要$O(logN)$的空间(递归)

```python
class Solution:
    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:
        res = []
        intervals.append(newInterval)
        intervals.sort(key=lambda x: x[0])
        for i in range(len(intervals)):
            if not res:
                res.append(intervals[i])
            elif res[-1][1] < intervals[i][0]:
                res.append(intervals[i])
            elif res[-1][1] >= intervals[i][0] and res[-1][1] <= intervals[i][1]:
                res[-1][1] = intervals[i][1]
            elif res[-1][1] >= intervals[i][0] and res[-1][1] > intervals[i][1]:
                continue
        return res
```

```python
class Solution:
    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:
        res = []
        intervals.append(newInterval)
        intervals.sort(key=lambda x: x[0])
        for i in range(len(intervals)):
            if not res:
                res.append(intervals[i])
            elif res[-1][1] < intervals[i][0]:
                res.append(intervals[i])
            else:
                res[-1][1] = max(res[-1][1], intervals[i][1])
        return res
```

## 解2

### 思路
1. 对于区间 $S_1 = [l_1, r_1]$ 和 $S_2 = [l_2, r_2]$, 如果它们之间没有重叠(没有交集)
- 说明要么 $S_1$ 在 $S_2$ 的左侧, 此时有 $r_1 < l_2$
- 要么 $S_1$ 在 $S_2$ 的右侧，此时有 $l_1 > r_2$
- 如果 $r_1 < l_2$ 和 $l_1 > r_2$ 二者均不满足, 说明 $S_1$ 和 $S_2$ 必定有交集, 它们的交集即为
$$[\max(l_1, l_2), \min(r_1, r_2)]$$
并集即为
$$[\min(l_1, l_2), \max(r_1, r_2)]$$

2. 当我们遍历到区间 $[l_i, r_i]$ 时:
- 如果 $r_i < \textit{left}$, 说明 $[l_i, r_i]$ 与 `S` 不重叠并且在其左侧, 我们可以直接将 $[l_i, r_i]$ 加入res
- 如果 $l_i > \textit{right}$, 说明 $[l_i, r_i]$ 与 `S` 不重叠并且在其右侧, 我们可以直接将 $[l_i, r_i]$ 加入res
- 如果上面两种情况均不满足，说明 $[l_i, r_i]$ 与 `S` 重叠, 我们无需将 $[l_i, r_i]$ 加入res. 此时, 我们需要将 `S` 与 $[l_i, r_i]$ 合并, 即将 `S` 更新为其与 $[l_i, r_i]$ 的并集

### 复杂度
1. 时间复杂度$O(N)$
2. 空间复杂度$O(1)$

```python
class Solution:
    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:
        newLeft, newRight = newInterval
        res = []
        placed = False
        for left, right in intervals:
            if newRight < left:
                if not placed:
                    res.append([newLeft, newRight])
                    placed = True
                res.append([left, right])
            elif right < newLeft:
                res.append([left, right])
            else:
                newLeft = min(left, newLeft)
                newRight = max(right, newRight)
        if not placed:
            res.append([newLeft, newRight])
        return res
```